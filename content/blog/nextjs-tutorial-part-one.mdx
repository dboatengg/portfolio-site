---
title: "Next.js Tutorial for Beginners - Part 1"
date: "2025-11-21"
summary: "Learn how to build modern web applications with Next.js by mastering core concepts like routing, data fetching, etc."
tags:
  - Next.js
  - React
  - Web Development
  - Tutorials
  - Programming
---
React is excellent for building user interfaces, but it doesn’t include many of the tools needed to build a full web application. 
Out of the box, React doesn’t handle routing, server-side rendering, SEO optimization, API endpoints, or performance optimizations.

If you try to build a production-ready application with only React, you often end up installing and configuring many external libraries: 
<b>React Router, Axios, Vite/Webpack, server frameworks, SSR tools</b>, and more. Managing all of this yourself quickly becomes complicated 
and makes your code harder to maintain.

This is exactly the problem Next.js solves. Next.js combines React with routing, server rendering, data fetching, file-based organization, 
and backend logic, all in one environment and already configured for you. Instead of managing a collection of separate tools and libraries 
on your own, Next.js gives you a complete, unified setup right from the start.

## Prerequisite
Before you proceed, make sure you have:

- Basic knowledge of JavaScript and TypeScript
- Familiarity with React fundamentals (components, props, JSX)
- Node.js 20.9 or later installed on your computer. You can download it [here](https://nodejs.org/).

## Goals

- Understand the core concepts of Next.js and how the App Router works.
- Build a practical, real-world Movie Browsing App that applies each concept step by step. 

You can explore the full project here:

- [View Source Code on GitHub](https://github.com/dboatengg/nextjs-tutorial-project)
- [View Live Demo](https://movie-app-project-brown.vercel.app/)

## Key Terms You Should Know

Before we dive into it, let’s clarify a few important technical terms you’ll see throughout this tutorial. Understanding these will help you follow along more easily:

- <b>Routing:</b> The process by which your application determines the page or content to display when a user visits a specific URL. In Next.js, routing is mostly file-based; you create folders and files, and each one automatically becomes a route in your app.
- <b>Route</b>: A route is simply a specific URL path in your application, like `/about`, `/contact`, or `/movies`. URL paths such as `/products/shoes` are also routes. Each route represents a different page that a user can visit.
- <b>App Router</b>: This refers to the setup in a Next.js application that controls how pages are created and connected within your project. Next.js reads the folders and files inside the `app/` directory and automatically turns them into URLs. Each folder represents a segment of a route, and special files like `page.tsx`, `layout.tsx`, and `loading.tsx` tell Next.js how that part of the app should behave.
- <b>Segment</b>: A segment is a single part of a route, and in the App Router, each segment is represented by a folder inside the `app/` directory. For example, in the route `/products/shoes`, the segments are <b>"products"</b> and <b>"shoes"</b>.

## What We’ll be Building

In this tutorial, we’ll build a Movie  Browsing application that has:

- A homepage
- About page
- A movie page that fetches a list of popular films from a real public API
- Individual movie pages using dynamic routes to show movie details
- Loading and error states 
- Clean, responsive UI styled with Tailwind
- Optimized images, metadata, and a shared layout
- A search bar where users can type to search for movies

By the end, you’ll have a strong foundation to start building your own production-ready Next.js applications.

## Setting Up Next.js

Before we start writing any code, we need to create a new Next.js project. Fortunately, Next.js comes with a command-line tool that handles all the setup for you.

To create a new project, open your terminal and run:

```bash
npx create-next-app@latest my-app
```

You’ll be asked a few setup questions (TypeScript, Tailwind, the App Router, etc.). For this tutorial, simply press <b>Enter</b> to accept all the recommended defaults.  
Once the installation finishes, move into your new project folder:

```bash
cd my-app
```

Then start the development server:

```bash
npm run dev
```

You’ll see a local URL such as:

```bash
http://localhost:3000
```

Open it in your browser and you’ll see a fresh Next.js project already running.

At this point, you have everything you need to begin this tutorial.

- An `app/` directory for routing
- A default layout page
- A homepage
- A development environment that reloads automatically whenever you save changes.

If you open the project in your code editor, you’ll notice a clean structure. The `app/` folder contains your routes, `globals.css` contains your global styles, and the rest of the files give you a fully configured foundation to start building immediately.

### Remove Tailwind’s Default Styling 

When you create a new Next.js project, Tailwind CSS comes preinstalled along with some default styles in `app/globals.css`. For this tutorial, we want a clean starting point so your project matches the screenshots and code samples exactly.

Open `app/globals.css`.

Keep the first line:

```css
@import "tailwindcss";
```

Then comment out or delete everything below it:

```css
@import "tailwindcss";

/* :root {
  --background: #ffffff;
  --foreground: #171717;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
} */

```

Next, open `app/layout.tsx` and update it by commenting out the global CSS import:

```jsx
// import "./globals.css"; // Comment out Tailwind’s default global styles

export const metadata = {
  title: "My Next.js App",
  description: "Learning Next.js step by step",
};

export default function RootLayout({
  children,
}: Readonly<{ children: React.ReactNode }>) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  );
}
```

(We will re-enable this import later when we get to Tailwind styling.)

This keeps Tailwind fully enabled, but removes the default styling so your layout and pages look exactly like the examples you’ll build throughout this tutorial.

## Understanding the Folder Structure

After creating your Next.js project, one of the first things you’ll notice is that it comes with a clean, well-organized folder structure. This structure defines how your application works, where your pages live, and how routing works.

Here’s a quick overview of the most important parts:

```lua
my-app/
 ├─ app/
 │   ├─ layout.js
 │   ├─ page.tsx
 │   └─ globals.css
 ├─ public/
 ├─ package.json
 └─ next.config.js
```

### 1. <b>`app/`</b>

This is the heart of your application. Every folder and file inside `app/` contributes to your routing system.

- `page.tsx` creates a route
- `layout.js` acts as a wrapper component that ensures common elements such as headers, footers, sidebars, and navigation bars remain consistent across multiple pages.
- Folders inside `app/` → automatically become segments.

You’ll spend most of your development time inside this `app/` folder.

### 2. `public/`

A place for static files such as images, icons, and fonts. Anything inside this folder can be accessed directly through the browser.

### 3. `globals.css` 

Your global stylesheet. Any CSS code you place here applies to every page in the app. This file is also where Tailwind’s base styles are imported.

### 4. `package.json`

Tracks your project’s dependencies and scripts. When you run commands like `npm run dev`, this file is what makes it possible.

### 5. `next.config.js`

Your project’s configuration file. You’ll rarely need to touch it when starting out, but it becomes useful for optimizations and advanced features later.

## Your First Steps Inside a New Next.js Project

Let’s start by customizing the homepage so you can get a feel for how routing works in the App Router.

Open `app/page.tsx`, delete the existing default code, and replace it with:

```jsx
export default function Home() {
  return (
    <main>
      <h1>Hello, World!</h1>
      <p>This is my first page.</p>
    </main>
  );
}
```

Save the file. Your browser will reload instantly, and you should see the content you just added on the homepage. This is one of the nicest parts of the App Router: every `page.tsx` file is automatically treated as a route.

Now, let’s create a second page to understand routing more clearly. Inside the `app/` directory, create a new folder named `about`, and inside it, add a `page.tsx` file:

```markdown
app/
 ├─ page.tsx
 ├─ layout.js
 └─ about/
     └─ page.tsx
```

In `app/about/page.tsx`, add this save:

```jsx
export default function About() {
  return (
    <main>
      <h1>About Page</h1>
      <p>This is the About page.</p>
    </main>
  );
}
```

Now open:

```bash
http://localhost:3000/about
```

Your new page is already live. 

### Why This Works

This is the core idea behind the App Router in Next.js:

Create a folder → add `page.tsx` → you get a new route.

There’s no routing configuration, no special APIs, and nothing else to set up. The folder structure *is* the routing system.


## Adding Navigation with the `<Link>` Component

Now that we have multiple pages (Home and About), let’s make it easy for users to navigate between them. 

In plain HTML, you’d normally use an `<a>` tag, but in Next.js, we use the `<Link>` component instead. The reason is simple: `<Link>` switches pages instantly without doing a full page reload, which makes your application feel much faster.

Open `app/page.tsx` (your homepage) and update it:

```jsx
import Link from "next/link"; // New import for navigation

export default function Home() {
  return (
    <main>
      <h1>Hello, World!</h1>
      <p>This is my first page.</p>
      
      {/* New: Link to the About page */}
      <p>
        <Link href="/about">Go to About Page</Link>
      </p>
    </main>
  );
}
```

Now do the same for the About page so you can return home:

```jsx
import Link from "next/link"; // New import for navigation

export default function About() {
  return (
    <main>
      <h1>About This App</h1>
      <p>This page lives at /about.</p>

        {/* New: Link back to the Home page */}
      <p>
        <Link href="/">Back to Home</Link>
      </p>
    </main>
  );
}
```

Now, go to your browser and try clicking the links. 

Notice how the page changes instantly: no white flash, no loading delay, no full refresh. This is one of the reasons Next.js web applications feel fast and behave like mobile apps rather than websites.

## Customizing the `layout.js` File

Every route in the App Router can have a layout file that wraps its pages. Think of it as the part of your application that holds the things you want to stay on the screen all the time. It’s the perfect place for things like a header, footer, or navigation bar.

Open `app/layout.js`, and you’ll see something like this:

```jsx
import type { Metadata } from "next";

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({children}: Readonly<{
  children: React.ReactNode}>) {
  return (
    <html lang="en">
      <body>
        {children}
      </body>
    </html>
  );
}
```

Let’s add a simple header that will appear on every page:

```jsx
import type { Metadata } from "next";
import Link from "next/link";

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({children}: Readonly<{
  children: React.ReactNode}>) {
  return (
    <html lang="en">
      <body>
        <header style={{ padding: "1rem", background: "#f3f3f3" }}>
          <nav style={{ display: "flex", gap: "1rem" }}>
            <Link href="/">Home</Link>
            <Link href="/about">About</Link>
          </nav>
        </header>

        <main style={{padding:"1rem"}}>
          {children}
        </main>

      </body>
    </html>
  );
}
```

Save and refresh the browser. You’ll now see the header appear on *every* page instantly.

You’ve now experienced one of the biggest benefits of layouts: you write code for things like headers or navigation bars once, and every page automatically uses them.

### Your Project Now Has:

- A homepage
- An About page
- Navigation between them
- A layout that wraps everything with a consistent structure

This is already the foundation of every real-world Next.js project.

## Data Fetching in Next.js

Now that your project has multiple pages, navigation, and a layout, it’s time to fetch real data. This is a crucial skill because our movie application project will rely heavily on fetching data from external APIs.

In Next.js, data fetching works differently from plain React. Most data is fetched on the server, not in the browser. This gives you:

- faster pages
- quicker load times and smoother transitions
- better performance on slow devices

The key rule is:

> In the App Router, any component that doesn’t have `"use client"` at the top is a Server Component. This means the component runs on the server and can be used to fetch data directly.

Let’s see how this works.

### Fetching Data in a Server Component

Create a new route called `/posts`:

```lua
app/
 ├─ page.tsx
 ├─ about/
 │   └─ page.tsx
 └─ posts/
     └─ page.tsx
```

Open `app/posts/page.tsx` and add:

```jsx
type Post = {
  id: number;
  title: string;
  body: string;
};

export default async function PostsPage() {
  // This is a fake API, but perfect for learning
  const res = await fetch("https://jsonplaceholder.typicode.com/posts");
  const posts:Post[] = await res.json();

  return (
    <main>
      <h1>Posts</h1>
      <ul>
        {posts.slice(0, 5).map((post) => (
          <li key={post.id} style={{ marginBottom: "1rem" }}>
            <strong>{post.title}</strong>
            <p>{post.body}</p>
          </li>
        ))}
      </ul>
    </main>
  );
}
```

### What This Does

- Defines a Post type so TypeScript knows the shape of the data you’re working with.
- Fetches data on the server by calling `fetch` inside a Server Component.
- Retrieves real posts from the JSONPlaceholder API and converts the response to JavaScript with `await res.json()`.
- Displays only the first 5 posts using `posts.slice(0, 5)`.
- Renders each post inside a list.

Now, visit:

[http://localhost:3000/posts]()

You’ll see the posts list instantly. Next.js fetches the data on the server, builds the HTML, and sends a complete page to the browser.

## Updating Data in Next.js

Most of the time, the data you fetch in a Server Component won’t change very often. When that happens, Next.js automatically caches the data and serves it quickly to every visitor.

But what if your data *does* change?

Next.js gives you two simple ways to control how often your data should be updated.

### 1. Update the data every X seconds

If you want the page to update from time to time, add this at the top of your data fetching component or file:

```jsx
export const revalidate = 60; // Refresh every 60 seconds
```

Next.js will:

- serve the page instantly
- Update the data in the background.
- show the new data automatically after the time interval

This is great for pages that change occasionally, like “Latest Movies,” “Top Rated,” or any list that updates from time to time.

### 2. Always fetch fresh data

If your data changes constantly, or depends on the user (like notifications, dashboards, or live activity), you can disable caching completely:

```jsx
fetch(url, { cache: "no-store" });
```

This tells Next.js:  
<b>“Always fetch new data whenever someone visits the page.”</b>

### The Simple Mental Model

- <b>Default</b> → data is cached
- <b>Add</b> `revalidate` → update occasionally.
- <b>Use</b> `no-store` → always update.

These three rules are all you need to control how your application updates its data.

## Dynamic Routes

In the previous section, you learned how to fetch and display data using the JSONPlaceholder API. But what if you want users to click a post and see its full details on a separate page? This is where dynamic routes come in.

A dynamic route lets you generate pages like this:

```lua
/posts/1
/posts/2
/posts/3
```

...from just a single file. You don’t manually create a page for every post. Instead, you use a folder with square brackets to capture the part of the URL that changes.

Let’s see how this works.

### 1. Create a Dynamic Folder:

In your `app` directory, create a new folder named `[id]` inside your `posts` folder like this:

```jsx
app/posts/[id]/page.tsx
```

1. Add the Dynamic Page:
Inside `app/posts/[id]/page.tsx`, create a page that fetches the details for a specific post using the `id` from the URL:

```jsx
// app/posts/[id]/page.tsx
export default async function PostDetailsPage({ params }: { params: { id: string } }) {
  const res = await fetch(`https://jsonplaceholder.typicode.com/posts/${params.id}`);
  if (!res.ok) {
    return <div>Could not load post.</div>;
  }
  const post = await res.json();
  return (
    <div>
      <h1>{post.title}</h1>
      <p>{post.body}</p>
      <p><strong>Post ID:</strong> {post.id}</p>
    </div>
  );
}
```

### Link to Dynamic Pages:

In your main posts listing page (`app/posts/page.tsx`), add links to each individual post page:

```jsx
// app/posts/page.tsx (add inside your map)
import Link from "next/link";

// ...inside your component:
{posts.map(post => (
  <li key={post.id}>
    <Link href={`/posts/${post.id}`}>{post.title}</Link>
  </li>
))}

```

Now, when a user clicks a post title, they’ll be taken to `/posts/1`, `/posts/2`, etc., and see the details for that specific post.

### Why Dynamic Routes Are Useful

- They let you generate a unique page for each item in your data (posts, users, products, etc.).
- You only need one `[id]/page.tsx` file, no matter how many posts you have.
- You can fetch and display information based on what’s in the URL.

## Handling Loading and Error States in Next.js

Any time your application fetches data, two things can happen:

1. The data takes a moment to load.
2. Something goes wrong while loading it.

In plain React, you’d manage both situations yourself using `useState`, `useEffect`, and lots of conditional rendering. In the App Router, Next.js gives you a much simpler system: special files that automatically handle these states for you.

The idea is straightforward:

- Add a `loading.tsx` file → It shows while the route is fetching data.
- Add an `error.tsx` file → shown when something goes wrong.

You don’t import anything or manually wrap your components. Next.js handles all the logic.

### Adding a Loading State

Inside your `app/posts/` folder, create a new file:

```lua
app/
 └─ posts/
      ├─ page.tsx
      └─ loading.tsx
```

Add this inside `loading.tsx`:

```jsx
export default function Loading() {
  return (
    <div style={{ padding: "1rem" }}>Loading posts...</div>
  );
}
```

Next.js will automatically show this whenever:

- The`/posts` route is fetching data.
- The server takes a moment to render
- The response from the API is slow.

You don’t need to manage any state; it just works. 

Now, try refreshing the `/posts` page and you’ll see the loading message appear briefly before the content.

### Adding an Error State

Still inside the `app/posts/` folder, create:

```lua
app/
 └─ posts/
      ├─ page.tsx
      ├─ loading.tsx
      └─ error.tsx
```

Add this inside `error.tsx`:

```jsx
"use client";

interface ErrorProps {
  error: Error & { digest?: string };
  reset: () => void;
}

export default function Error({ error, reset }: ErrorProps) {
  return (
    <div style={{ padding: "1rem", color: "red" }}>
      <h2>Something went wrong.</h2>
      <p>{error.message}</p>

      <button onClick={reset} style={{ marginTop: "1rem" }}>
        Try again
      </button>
    </div>
  );
}
```

#### A few things to notice:

- `error.js` must be a Client Component, so it needs `"use client"`.
- If something goes wrong in `page.tsx`, like a failed fetch, a bug in your code, or a network problem, Next.js will automatically show this error message to the user.
- `reset()` lets the user retry the page, triggering a new data fetch.

Try forcing an error in `page.tsx` by using an incorrect API endpoint:

```jsx
const res = await fetch("https://jsonplaceholder.typicode.com/invalid-url");
```

When you visit `/movies`, Next.js will automatically:

- Show your custom error screen from `error.tsx`
- Provide the error message.
- allow the user to retry using `reset()`

This demonstrates exactly how real data-fetching issues get handled in the App Router.

## Why Loading and Error Files Matter

In traditional React:

- You write loading logic for every fetch.
- You write error logic for every fetch.
- You repeat the same code everywhere.

In Next.js:

- One `loading.js` per route
- One `error.js` per route
- Next.js handles everything automatically.

This keeps your code clean and free of repetitive boilerplate, especially as pages grow more complex.

## Styling With Tailwind CSS

Up to this point, we’ve added small inline styles here and there just to keep things readable. Now it’s time to introduce a better way to style your application.

Tailwind CSS is one of the most popular ways to style Next.js apps. Instead of writing long CSS rules, you add small utility classes directly to your markup. It may look different at first, but it quickly becomes one of the most productive ways to style modern applications.

The best part? 

Tailwind comes preconfigured when you create a new Next.js project, so you don’t need to install anything else. You can start using it immediately inside your project.

## Styling Your Layout With Tailwind

Let’s update the layout you built earlier to look cleaner.

Open `app/layout.tsx` and update it to match the version below:

```jsx
import Link from "next/link";
import './globals.css';

export const metadata = {
  title: "My Next.js App",
  description: "Learning Next.js step by step",
};

export default function RootLayout({ children }:Readonly<{children: React.ReactNode}>) {
  return (
    <html lang="en">
      <body className="bg-gray-50 text-gray-900">
        <header className="bg-gray-100 shadow-sm">
          <nav className="max-w-4xl mx-auto flex items-center gap-6 p-4">
            <Link href="/" className="hover:underline">
              Home
            </Link>
            <Link href="/about" className="hover:underline">
              About
            </Link>
            <Link href="/posts" className="hover:underline">
              Posts
            </Link>
          </nav>
        </header>

        <main className="max-w-4xl mx-auto p-4">
          {children}
        </main>
      </body>
    </html>
  );
}
```

Look at your app now, it already feels more professional.

## Styling a Page With Tailwind

Now let’s style your `/posts` page so it looks cleaner and more modern.

Update `app/posts/page.tsx` to the following:

```jsx
type Post = {
  id: number;
  title: string;
  body: string;
};

export default async function PostsPage() {
  const res = await fetch("https://jsonplaceholder.typicode.com/posts");
  const posts:Post[] = await res.json();

  return (
    <div>
      <h1 className="text-2xl font-semibold mb-6">Posts</h1>

      <ul className="space-y-4">
        {posts.slice(0, 5).map((post) => (
          <li
            key={post.id}
            className="p-4 bg-white rounded-lg shadow-sm border"
          >
            <h2 className="font-medium text-lg">{post.title}</h2>
            <p className="text-gray-700">{post.body}</p>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

With just a few classes, your page now has:

- better spacing
- clearer typography
- a clean, readable layout
- modern card-style UI for each post

## Using Images in Next.js

Next.js comes with a built-in `<Image />` component for displaying images. It replaces the regular `<img>` tag and gives you automatic optimizations such as:

- faster loading
- responsive sizes out of the box
- lazy loading

Let’s walk through it step by step.

### 1. Add an Image to Your Project

Place an image inside the `public/` folder at the root of your project. Anything inside `public/` can be used directly in your components.

Example:

```lua
public/
 └─ test-image.png
```

### 2. Use the Image in a Page

Let’s display the image on the About page.

Open `app/about/page.tsx` and update it:

```jsx
import Link from "next/link";
import Image from "next/image";

export default function About() {
  return (
    <main>
      <h1 className="text-2xl font-semibold mb-4">About This App</h1>

      <Image
        src="/laptop.png"
        alt="Laptop illustration"
        width={500}
        height={350}
        className="rounded-lg shadow-md mb-4"
      />

      <p>This page lives at /about.</p>

      <p className="mt-4">
        <Link href="/" className="text-blue-600 hover:text-blue-800">
          Back to Home
        </Link>
      </p>
    </main>
  );
}
```

Now, when you visit the about page, you will see the image displayed there.

How It Works

- The image file sits inside the `public/` folder.
- You reference it with `src="/laptop.png"`
- You must provide `width` and `height.`
- Next.js automatically optimizes the image for speed.

This gives you a clean, responsive image without writing CSS or resizing anything manually.